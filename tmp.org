#+TITLE: tmp
#+DESCRIPTION: 笔记文件的暂存，配置完成后重构笔记文件

* 死锁

** 死锁预防

*** 破坏循环等待条件

*资源分配法*：
首先给系统中的资源编号，规定每个进程*必须按编号递增的顺序请求资源*，
同类资源（即编号相同的资源）一次申请完。

*缺点*：
1. 不方便增加新的设备，因为可能需要重新分配所有的编号
2. 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费
3. 必须按规定次序申请资源，用户编程麻烦

** 死锁避免

*** 系统安全状态和安全序列

*安全序列*：
如果系统安装这种序列分配资源，则每个进程都能顺利完成。

如果能找到一个安全序列，则当前系统处于安全状态，
安全序列可能有多个。

系统处于安全状态   --> 一定不会发生死锁
系统处于不安全状态 --> 可能发生死锁

*** 银行家算法--Dijkstra

*核心思想*：
在资源分配之前预先判断这次分配是否会导致系统进入不安全状态，
以此决定是否答应资源分配请求。

系统中有n个进程，m种资源

n = 5, m = 3

m.value = ? ? ?

Available = 3 3 2

| 进程\资源情况 | Max   | Allocation | Need  |
|---------------+-------+------------+-------|
| P0            | 7 5 3 | 0 1 0      | 7 4 3 |
| P1            | 3 3 2 | 2 0 0      | 1 3 2 |
| P2            | 9 0 2 | 3 0 2      | 6 0 0 |
| P3            | 2 2 2 | 2 1 1      | 0 1 1 |
| P4            | 4 3 3 | 0 0 2      | 4 3 1 |

| 安全序列 | Work                   | Need  | Allocation | Work + Allocation |
|----------+------------------------+-------+------------+-------------------|
| P1       | 3 3 2 (Available)      | 1 3 2 | 2 0 0      | 5 3 2             |
| P3       | 5 3 2 (Work+Available) | 0 1 1 | 2 1 1      | 7 4 3             |
| P0       | 7 4 3                  | 7 4 3 | 0 1 0      | 7 5 3             |
| P2       | 7 5 3                  | 6 0 0 | 3 0 2      | 10 5 5            |
| P4       | 10 5 5                 | 4 3 1 | 0 0 2      | 10 5 7 (m.value)  |

安全序列： P1->P3->P0->P2->P4

** 死锁检测和解除

*** 资源分配图 -- 死锁的检测

使用资源分配图这种数据结构来保存资源的请求和分配信息

- *资源分配图*
  - 两种结点
    - 进程结点：对应一个进程
    - 资源结点：对应一类资源，一类资源可以有多个
  - 两种边
    - 进程结点 --> 资源结点：表示进程想申请几个资源（一条边代表一个）
    - 资源结点 --> 进程结点：表示已经为进程分配了几个资源（每条边代表一个）

可以执行完的进程可以把相连的边消除

如果最终能消除所有边，则是*可完全简化的*。（一定没有死锁）

如果不能消除所有边，则发生了死锁。
最终还连着边的进程是处于死锁状态的进程。

*** 死锁的解除

1. 资源剥夺法。
2. 撤销进程法（终止进程法）。
3. 进程回退法。

影响被操作进程的因素：
1. 进程优先级
2. 已执行时间
3. 还要多久能完成
4. 进程已经使用了多少资源
5. 进程是交互式还是批处理式的
